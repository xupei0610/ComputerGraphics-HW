"#version 330 core\n"
"out vec4 color;"
""
"in vec2 tex_coords;"
"in vec3 t_norm;"
"in vec3 t_cam_pos;"
"in vec3 t_frag_pos;"
"in vec3 t_headlight_pos;"
"in vec3 t_headlight_dir;"
""
"uniform vec3 global_ambient;"
""
"struct SpotLight"
"{"
"   vec3 pos;"
"   vec3 dir;"
"   float cutoff_outer;"
"   float cutoff_diff;"
"   "
"   vec3 ambient;"
"   vec3 diffuse;"
"   vec3 specular;"
""
"   float coef_a0;"
"   float coef_a1;"
"   float coef_a2;"
"};"
"uniform SpotLight headlight;"
""
"struct Material"
"{"
"   vec3 ambient;"
"   sampler2D diffuse;"
"   sampler2D normal;"
"   sampler2D specular;"
"   sampler2D displace;"
"   float shininess;"
"   float displace_amp;"
"   float displace_mid;"
"   float parallel_height;"
"};"
"uniform Material material;"
""
"uniform int use_tangent;"
""
"struct PointLight"
"{"
"   vec3 pos;"
"   vec3 ambient;"
"   vec3 diffuse;"
"   vec3 specular;"
"   float coef_a0;"
"   float coef_a1;"
"   float coef_a2;"
"};"
"\n#define MAX_POINT_LIGHTS 5\n"
"uniform PointLight pointlight[MAX_POINT_LIGHTS];"
"flat in vec3 pointlight_pos[MAX_POINT_LIGHTS];"
""
"vec4 calPointLight(PointLight, vec3, vec3, vec3, vec3, vec3, vec3);"
""
"void main() {"
""
"   vec3 V = normalize(t_cam_pos - t_frag_pos);"
""
"   vec2 t_tex_coords = tex_coords;"
"   if (material.parallel_height != 0.f)"
"   {"
"       vec3 dv = texture(material.displace, tex_coords).xyz;"
"       float df = 0.30*dv.x + 0.59*dv.y + 0.11*dv.z;"
"       t_tex_coords += V.xy/V.z * (df * material.parallel_height);"
//"       if (t_tex_coords.x < 0.f || t_tex_coords.x > 1.f || t_tex_coords.y < 0.f || t_tex_coords.y > 1.f)"
//"        discard;"
"   }"
""
"   vec3 N;"
"   if (use_tangent == 1)"
"   {   "
"       N = texture(material.normal, t_tex_coords).rgb;"
"       N = normalize(N * 2.f - 1.f);"
"   }"
"   else"
"   {"
"       N = t_norm;"
"   }"
""
"   vec3 obj_color = texture(material.diffuse, t_tex_coords).rgb * material.ambient;"
""
"   color = vec4(global_ambient * obj_color, 1.f);"
""
"   vec3 specular = texture(material.specular, t_tex_coords).rgb;"
""
"   for (int i = 0; i < MAX_POINT_LIGHTS; ++i)"
"   {"
"       color += calPointLight(pointlight[i], pointlight_pos[i], N, V, t_frag_pos, obj_color, specular);"
"   }"
""
""  // headlight
"   vec3 ambient = headlight.ambient * obj_color;"                       // ambient
"   "
"   vec3 L = normalize(t_headlight_pos - t_frag_pos);"
"   vec3 diffuse =  abs(dot(L, N)) * headlight.diffuse * obj_color;" // diffuse
""
//        "   vec3 R = reflect(-L, N);"
"   vec3 H = normalize(L + V);" // blinn phong
"   float spec = pow(abs(dot(N, H)), material.shininess);"
"   specular *= headlight.specular * spec;"    // specular
""
"   float cosine = -dot(L, normalize(t_headlight_dir));"
"   float intensity = max(min((cosine - headlight.cutoff_outer)/headlight.cutoff_diff, 1), 0);"
"   "
"   float dist = length(t_headlight_pos - t_frag_pos);"
"   float atten = 1.f / (headlight.coef_a0 + headlight.coef_a1 * dist + headlight.coef_a2*dist*dist);"
""
"   float coef = intensity * atten;"
"   ambient  *= coef;"
"   diffuse  *= coef;"
"   specular *= coef;"
""
"   color += vec4((ambient + diffuse + specular), 0.f);"
"}"
"   "
"vec4 calPointLight(PointLight light, vec3 light_pos, vec3 norm, vec3 view, vec3 frag_pos, vec3 diffuse, vec3 specular)"
"{"
"    if (light.coef_a0 == 0.f && light.coef_a1 == 0.f && light.coef_a2 == 0.f)"
"       return vec4(0, 0, 0, 0);"
""
"    vec3 L = light_pos - frag_pos;"
"    float dist = length(L);"
"    L /= dist;"
"    vec3 R = reflect(-L, norm);"
""
"    float diff = max(dot(norm, L), 0.0);"
"    float spec = pow(max(dot(view, R), 0.0), material.shininess);"
""
"    float atten = 1.0f / (light.coef_a0 + light.coef_a1 * dist + light.coef_a2*dist*dist);"
""
"    vec3 a = light.ambient * diffuse;"
"    vec3 d = light.diffuse * diff * diffuse;"
"    vec3 s = light.specular * spec * specular;"
"    return vec4((a+d+s) * atten, 0.f);"
"}"