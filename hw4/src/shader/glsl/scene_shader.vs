"#version 330 core\n"
"layout (location = 0) in vec3 v;"
"layout (location = 1) in vec2 v_tex_coord;"
"layout (location = 2) in vec3 v_norm;"
"layout (location = 3) in vec3 v_tangent;"
""
""
"out vec2 tex_coords;"
"out vec3 t_norm;"
"out vec3 t_cam_pos;"
"out vec3 t_frag_pos;"
"out vec3 t_headlight_pos;"
"out vec3 t_headlight_dir;"
""
"uniform mat4 model;"
"uniform mat4 view;"
"uniform mat4 proj;"
"uniform vec3 cam_pos;"
""
"struct SpotLight"
"{"
"   vec3 pos;"
"   vec3 dir;"
"   float cutoff_outer;"
"   float cutoff_diff;"
"   "
"   vec3 ambient;"
"   vec3 diffuse;"
"   vec3 specular;"
""
"   float coef_a0;"
"   float coef_a1;"
"   float coef_a2;"
"};"
"uniform SpotLight headlight;"
""
"struct Material"
"{"
"   vec3 ambient;"
"   sampler2D diffuse;"
"   sampler2D normal;"
"   sampler2D specular;"
"   sampler2D displace;"
"   float shininess;"
"   float displace_amp;"
"   float displace_mid;"
"   float parallel_height;"
"};"
"uniform Material material;"
""
"uniform int use_tangent;"
""
"struct PointLight"
"{"
"   vec3 pos;"
"   vec3 ambient;"
"   vec3 diffuse;"
"   vec3 specular;"
"   float coef_a0;"
"   float coef_a1;"
"   float coef_a2;"
"};"
"\n#define MAX_POINT_LIGHTS 5\n"
"uniform PointLight pointlight[MAX_POINT_LIGHTS];"
"flat out vec3 pointlight_pos[MAX_POINT_LIGHTS];"
""
"void main()"
"{"
"   tex_coords = v_tex_coord;"
""
"   vec3 vertex = v;"
"   if (material.displace_amp != 0.f)"
"   {"
"       vec3 dv = texture(material.displace, tex_coords).xyz;"
"       float df = 0.30*dv.x + 0.59*dv.y + 0.11*dv.z;"
"       vertex += (df - material.displace_mid) * material.displace_amp * v_norm;"
"   }"
""
"   if (use_tangent == 1)"
"   {"
"       mat3 norm_mat = transpose(inverse(mat3(model)));"
"       vec3 T = normalize(norm_mat * v_tangent);"
"       vec3 N = normalize(norm_mat * v_norm);"
"       T = normalize(T - dot(T, N) * N);"
"       vec3 B = cross(N, T);"
"       mat3 TBN = transpose(mat3(T, B, N));"
"       t_cam_pos   = TBN * cam_pos;"
"       t_frag_pos  = TBN * vec3(model * vec4(vertex, 1.f));"
"       t_headlight_pos = TBN * headlight.pos;"
"       t_headlight_dir = TBN * headlight.dir;"
"       for (int i = 0; i < MAX_POINT_LIGHTS; ++i)"
"       {"
"           pointlight_pos[i] = TBN * pointlight[i].pos;"
"       }"
"   }"
"   else"
"   {"
"       mat4 VM = view * model;"
"       vec4 pos4 = VM * vec4(vertex,1.f);"
"       vec4 hpos4 = VM * vec4(headlight.pos,1.f);"
"       vec4 norm4 = transpose(inverse(VM)) * vec4(v_norm, 0.f);"
"       t_norm = norm4.xyz;"
"       t_cam_pos = vec3(0.f, 0.f, 0.f);"
"       t_frag_pos = pos4.xyz/pos4.w;"
"       t_headlight_pos = hpos4.xyz/hpos4.w;"
"       t_headlight_dir = (view * vec4(headlight.dir, 0.f)).xyz;"
"   }"
""
"   gl_Position = proj * view * model * vec4(vertex, 1.f);"
"}"
